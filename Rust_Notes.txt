export PATH='$PATH:C:/Users/Kishan/.rustup/toolchains/stable-x86_64-pc-windows-msvc/bin'


Two types of project
    - Binary  : End user application         
    - Library : dll/exe file for reusability of code

cargo init        : Start Project
cargo init --lib  : Start Library

Write variable/function in snake_case

signed number: i32 , i64
unsigned number: u32 , u64

// Mutability
    By default variables are Immutable/constant
    To make mutable varibale use "mut" keyword

// Struct 
    It lets you structure data together

//"&self" argument : similar to "this" in javascript

//Enum
   It lets you enumerate over various types of a value

//Enum with values 
    Provide associated values to enums

//Rust Enum: Options/Result
    [Null pointer, error handling] done via enums in rust
    Option : It lets you return either "Some" value or "None" value
    Result : It lets you return either "OK" value or "Err" value
 
    pub enum Option<T> {
        None,
        Some(T)
    }

    pub enum Result<T,E> {
        Ok(T),
        Err(E)
    }


// Package management
    You can add an external crate to your project by running 
     - cargo add crate_name
     - npm install rust


// Memory management
    #Stack
        -> Static, Allocated at compile time
        -> Smaller in size
        -> Faster
        -> Used for samll, fixed size variables and function call information
            - Numbers : i32, u64, f32
            - Booleans : true , false
            - Fixed sized arrays : [i32; 4]
            - Structs : { x:i32, y:i32 }
            - References (later)
    
    #Heap
        -> Dynamic, Allocated at run time
        -> Much larger in size
        -> Slower due to dynamic allocation and deallocation
        -> Used for Dynamic and large data structure 
            - String, Vector, HashMap, Large Arrays/Structs that cant fit in the stack

    # Size of stack frame [function memory in stack] needs to fixed but the size of string can changed hence string is stored in Heap and its address in stack

    => Speciality in Rust Memory management
     
     1] Garbage collector
        -> Written by smart people
        -> Usually no dangling pointer/memory issue
        -> You cant do manual memory management
        -> Exa: Java, javascript

    2] Manual
        -> You allocate/deallocate memory
        -> Can lead to dangling piniter/memory issue
        -> Exa: C

    3] The Rust way
        -> Rust has its own ownership model for MM
        -> Makes it extermely safe to memory errors
        -> Ownership + Moving + Borrowing + References

    => Ownership rule
        - Each value in Rust has an owner
        - There can only be one owner at time ( Which prevent double free problem)
        - When the owner goes out of scope, the value will be dropped

    => Moving 
        - The ownership of value can be transfered
        - Example
            let a = String::from("Kishan")
            let b = a;
            println("{}", a) // This will give error since a's ownership is moved to b variable
            println("{}", b) // This is coorect

            a = b // This moves back the owenership to a variable
            println("{}", a) // This is correct

    => Borrowing
        - Lend the varibale to perform action on that varibale by passing Reference
        - Example
            let a = String::from("Kishan")
            do_something(a1: &a)
            println("{}", a)

            let b = String::from("Yoo")
            do_something(b1: &mut b)
            println("{}", b)

            fn do_something(a1: &String) {
                // This function has borrowed a's value
                println!("{}", a1)
            }

            fn change_something(b1: &mut String) {
                // Now I can change the string
                b1.push_str(string: "Boy")                
            }
    
    => References
        - At any given time, you can have either one mutable reference or any number of immutable
        - Example
            fn main() {
                let mut s1 = String::from("Kishan");
                let s2 = &mut s1;  // Mutable Reference 
                let s3 = &s1;      // This is incorrect as above refrence is mutable , then reference need to mutable          
                println!("String is {}, {}, {}", s1, s2, s3);
            }

            
// Collection
    Rust's standard library includes a number of very useful data structure called collections.
    Most other data types represent one specific value, but collections can contain multiple values.
    The data these collections point to is stored on the heap.

    => Vector
        - It allows you to store more than one value in single data structure that puts all the value 
          next to each other in memory.

    => HashMap
        - It stores a key value pair in rust.
        - Common method : insert, get, remove, clear
    
 
// Rust Iterators
    An iterator in Rust is responsible for creating a sequence of values and allows us to iterate over each
    item of the sequence. It is primarily used for looping and we can only loop over iterators in Rust.
    In Rust, iterators are lazy, meaning they have no effect until you call methods that consume the iterator to use it up. 

    1] Iterating using for loop
            let nums = vec![1, 2, 3];

            for val in nums {
                println!("Got: {val}");
            }
    
    2] Iterating after creating an Iterator
            - Using the iter() method on a collection will borrow (reference) each element 
              of the collection in each iteration. We can't mutate varibale since we have immutable reference.

            - Example  
                let nums = vec![1, 2, 3];

                let iter = nums.iter();

                for val in iter {
                    println!("Got: {val}");
                }

    3] Iterating using .next()
            - Using the iter() method on a collection will borrow (reference) each element 
              of the collection in each iteration. We can't mutate varibale since we have immutable reference.
              Here iterator is mutable but inner elements (value) is still immutable.

            - Example  
                let nums = vec![1, 2, 3];

                let mut iter = nums.iter();

                while Some(value) = iter.next() {
                    println!("Got: {val}");
                }

    4] Iterating Using Mutable Iterator (iter_mut())
            - Using the iter_mut() method on a collection will mutably borrow each element 
              of the collection in each iteration. It means we can modify the collection in place.

            - Example  
                let nums = vec![1, 2, 3];

                let iter = nums.iter_mut();

                for val in iter {
                    *val = *val + 2;
                }
                println!("Add two in each element: {:?}", nums);

    5] Iterating Using into_iter
                - The IntoIterator trait is used to convert a collection into an iterator that takes ownership of
                  the collection. Useful when
                        1. You no longer need the original collection
                        2. When you need to squeeze performance benets by transferring ownership (avoiding references)
                - The for-loop syntax when applied directly on the collection uses into_iter under the hood

                - Example  
                    let nums = vec![1, 2, 3];

                    let iter = nums.into_iter();

                    for val in iter {
                        println!("Got: {val}");
                    }

    => Iterators : Which to chose?
        Iter  - If you want IMMUTABLE references to the inner variables and don’t want to transfer ownership
        IterMut - If you want MUTABLE references to the inner variables and don’t want to transfer ownership
        IterInto - If you want to move the variable into the iterator and don’t want to use it afterwards
    
    => Type of Iterators
        - Consuming Adapter : Methods that call "next" are called consuming adaptors, because calling them uses up the iterator.
                              One example is the sum method, which takes ownership of the iterator and iterates through the items
                              by repeatedly calling next, thus consuming the iterator. 

                                fn iterator_sum() {
                                    let v1 = vec![1, 2, 3];

                                    let v1_iter = v1.iter();

                                    let total: i32 = v1_iter.sum();

                                    assert_eq!(total, 6);
                                }

        - Producing Adapter : Iterator adapters are used to transform it into another kind of iterator by altering its behavior. 
                              For example, let's take a look at the map() adapter.

                                let numbers = vec![1, 2, 3];
                                numbers.iter().map(|i| i + 1);
                                numbers.iter().map(|i| i + 1).collect();

                                Here, the map() method takes a closure to call on each item on the vector numbers.
                                However, we will have to use the collect() method on the map() adapter to collect the result. 
                                This is because iterator adapters do not produce the result directly (lazy) without calling the collect() method.
                                This will return a vector containing each item from the original vector incremented by 1.

